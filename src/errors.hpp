#pragma once

#include "string_converter.hpp"
#include "options.hpp"

namespace calyx
{
    // Macros from https://stackoverflow.com/questions/1082192/how-to-generate-random-variable-names-in-c-using-macros
#define CONCAT(a, b) CONCAT_INNER(a, b)
#define CONCAT_INNER(a, b) a##b
#define LINE_UNIQUE_NAME(base) CONCAT(base, __LINE__)

    class Options;

    /**
     * @brief Stores commonly used error message factories. Note that these are not proper error holders!
     *
     */
    struct Errors
    {
        static String_t undefinedRule(const String_t& symbol, const Options& options);

        static String_t undefinedFilter(const String_t& symbol, const Options& options);

        static String_t incorrectFilterSignature(const String_t& symbol, const Options& options);
    };

    /**
     * @brief Stores error messages to keep compatibility with UE and its lack of exceptions.
     *
     * Errors are generated by setting an error message with {@link ErrorHolder#setError}, and then early returning with an arbitrary default
     * value, or by returning an empty {@link std::optional} to force the caller to deal with it
     *
     * Error Holders should always be passed by reference.
     */
    class ErrorHolder
    {
    public:
        /**
         * @brief Construct a new Error object with no errors
         *
         */
        ErrorHolder();

        ~ErrorHolder() = default;

        /**
         * @brief Errors should be passed by reference. The copy constructor is deleted to enforce this.
         *
         * @param old
         */
        ErrorHolder(const ErrorHolder& old) = delete;

        /**
         * @brief Errors should be passed by reference. The assignment operator is deleted to enforce this.
         *
         * @param other
         * @return Error&
         */
        ErrorHolder& operator=(const ErrorHolder& other) = delete;

        /**
         * @brief Determine if errors are present. Errors are present if and only if {@link ErrorHolder#setError} has been called on this instance.
         *
         * @return true Returns true if an error is present
         * @return false Returns false if an error is not present
         */
        bool hasError() const;

        /**
         * @brief Get the error message.
         *
         * @return const String_t& Returns the message if an error is present, otherwise returns an empty string.
         */
        const String_t& getMessage() const;

        /**
         * @brief Sets an error message to the given message, and also sets hasError to true.
         *
         * @param message The error message
         */
        void setError(String_t message);

    private:
        String_t _message;
        bool _hasError;
    };
}
