#pragma once

#include "string_converter.hpp"

namespace calyx
{
    // Macros from https://stackoverflow.com/questions/1082192/how-to-generate-random-variable-names-in-c-using-macros
#define CONCAT(a, b) CONCAT_INNER(a, b)
#define CONCAT_INNER(a, b) a##b
#define LINE_UNIQUE_NAME(base) CONCAT(base, __LINE__)

/**
 * @brief Macro used as a shorthand for explicitly ignoring errors. Creates an error holder that is passed as the last argument
 * into the expression. The "Expression" should be any normal C++ expression that ends with a function/method call, except instead
 * of putting the arguments in brackets, they are added onto the end of the macro.
 *
 * Example, generating random numbers:
 *
 * @code {.cpp}
 * IGNORE_ERRORS(int choice = options.randInt, min, max);
 * @endcode
 *
 * Will expand to...
 *
 * @code {.cpp}
 * ErrorHolder ignoredX = ErrorHolder();
 * int choice = options.randInt(min, max, ignoredX);
 * @endcode
 *
 */
#define IGNORE_ERRORS(EXPRESSION, ...)                     \
    ErrorHolder LINE_UNIQUE_NAME(ignored) = ErrorHolder(); \
    EXPRESSION(##__VA_ARGS__, LINE_UNIQUE_NAME(ignored));

    /**
     * @brief Stores commonly used error message factories. Note that these are not proper error holders!
     *
     */
    struct Errors
    {
        static String_t undefinedRule(const String_t& symbol, const StringConverter<String_t>& converter = StringConverters::DEFAULT_STRING_CONVERTER);

        static String_t undefinedFilter(const String_t& symbol, const StringConverter<String_t>& converter = StringConverters::DEFAULT_STRING_CONVERTER);

        static String_t incorrectFilterSignature(const String_t& symbol, const StringConverter<String_t>& converter = StringConverters::DEFAULT_STRING_CONVERTER);
    };

    /**
     * @brief Stores error messages to keep compatibility with UE and its lack of exceptions.
     *
     * Errors are generated by setting an error message with {@link ErrorHolder#setError}, and then early returning with an arbitrary default
     * value, or by returning an empty {@link std::optional} to force the caller to deal with it
     *
     * Error Holders should always be passed by reference.
     */
    class ErrorHolder
    {
    public:
        /**
         * @brief Construct a new Error object with no errors
         *
         */
        ErrorHolder();

        ~ErrorHolder() = default;

        /**
         * @brief Errors should be passed by reference. The copy constructor is deleted to enforce this.
         *
         * @param old
         */
        ErrorHolder(const ErrorHolder& old) = delete;

        /**
         * @brief Errors should be passed by reference. The assignment operator is deleted to enforce this.
         *
         * @param other
         * @return Error&
         */
        ErrorHolder& operator=(const ErrorHolder& other) = delete;

        /**
         * @brief Determine if errors are present. Errors are present if and only if {@link ErrorHolder#setError} has been called on this instance.
         *
         * @return true Returns true if an error is present
         * @return false Returns false if an error is not present
         */
        bool hasError() const;

        /**
         * @brief Get the error message.
         *
         * @return const String_t& Returns the message if an error is present, otherwise returns an empty string.
         */
        const String_t& getMessage() const;

        /**
         * @brief Sets an error message to the given message, and also sets hasError to true.
         *
         * @param message The error message
         */
        void setError(String_t message);

    private:
        String_t _message;
        bool _hasError;
    };
}
